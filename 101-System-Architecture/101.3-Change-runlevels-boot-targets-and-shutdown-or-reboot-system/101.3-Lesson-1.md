# 101.3 Изменение уровней запуска/целей загрузки и выключение или перезагрузка системы

Ключевые области знаний

- Установка уровня запуска или цели загрузки по умолчанию.
- Изменение между уровнями запуска/целями загрузки, включая однопользовательский режим.
- Завершение работы и перезагрузка из командной строки.
- Предупреждать пользователей перед переключением уровней запуска/целей загрузки или другими важными системными событиями.
- Правильно завершать процессы.
- Осведомленность об acpid.

Список используемых файлов, терминов и утилит

- `/etc/inittab`
- `shutdown`
- `init`
- `/etc/init.d/`
- `telinit`
- `systemd`
- `systemctl`
- `/etc/systemd/`
- `/usr/lib/systemd/`
- `wall`

## Введение

Общей чертой операционных систем, следующих принципам дизайна Unix, является использование отдельных процессов для управления различными функциями системы. Эти процессы, называемые демонами (или, в более общем смысле, службами), также отвечают за расширенные функции, лежащие в основе операционной системы, такие как службы сетевых приложений (HTTP-сервер, обмен файлами, электронная почта и т. д.), базы данных, конфигурация по требованию и т. д. Хотя Linux использует монолитное ядро, многие низкоуровневые аспекты операционной системы затрагиваются демонами, такими как балансировка нагрузки и настройка брандмауэра.

Какие демоны должны быть активны, зависит от назначения системы. Набор активных демонов также должен быть изменяем во время выполнения, чтобы службы можно было запускать и останавливать без необходимости перезагрузки всей системы. Для решения этой проблемы каждый основной дистрибутив Linux предлагает некоторую форму утилиты управления службами для управления системой.

Службами можно управлять с помощью сценариев оболочки или программы и ее поддерживающих файлов конфигурации. Первый метод реализован стандартом `SysVinit`, также известным как `System V` или просто `SysV`. Второй метод реализован `systemd` и `Upstart`. Исторически менеджеры служб на основе `SysV` были наиболее используемыми в дистрибутивах Linux. Сегодня менеджеры служб на основе` `systemd` чаще встречаются в большинстве дистрибутивов Linux. Менеджер служб — это первая программа, запускаемая ядром во время процесса загрузки, поэтому его PID (идентификационный номер процесса) всегда равен 1.

## SysVinit

Менеджер сервисов на основе стандарта `SysVinit` предоставит предопределенные наборы состояний системы, называемые уровнями запуска, и соответствующие им файлы скриптов сервисов для выполнения. Уровни запуска нумеруются от 0 до 6 и обычно назначаются для следующих целей:

`Runlevel 0`: - Выключение системы.  
`Runlevel 1, s or single`: - Однопользовательский режим, без сетевых и других возможностей (режим обслуживания).  
`Runlevel 2, 3 or 4` - Многопользовательский режим. Пользователи могут входить в систему через консоль или сеть. Уровни запуска 2 и 4 используются нечасто.  
`Runlevel 5` - Многопользовательский режим. Он эквивалентен 3, плюс вход в графический режим.  
`Runlevel 6` - Перезагрузка системы.

Программа, отвечающая за управление уровнями выполнения и связанными с ними демонами/ресурсами, — `/sbin/init`. Во время инициализации системы программа `init` идентифицирует запрошенный уровень выполнения, определенный параметром ядра или в файле `/etc/inittab`, и загружает связанные скрипты, перечисленные там для данного уровня выполнения. Каждый уровень выполнения может иметь много связанных служебных файлов, обычно скрипты, которые находятся в каталоге `/etc/init.d/`. Поскольку не все уровни выполнения эквивалентны в разных дистрибутивах Linux, краткое описание назначения уровня выполнения также можно найти в дистрибутивах на основе `SysV`.

Синтаксис файла `/etc/inittab` использует следующий формат:
```
id:runlevels:action:process
```
![image](https://github.com/user-attachments/assets/85b247bd-020e-4167-ada2-a9c0cd3212de)


Идентификатор `id` — это общее имя длиной до четырех символов, используемое для идентификации записи. Запись `runlevels` — это список номеров уровней выполнения, для которых должно быть выполнено указанное действие. Термин `action` определяет, как `init` будет выполнять процесс, указанный термином `process`. Доступны следующие действия:

`boot`
Процесс будет выполнен во время инициализации системы. Поле runlevels игнорируется.

`bootwait`
Процесс будет выполнен во время инициализации системы, а init будет ждать его завершения, чтобы продолжить. Поле runlevels игнорируется.

`sysinit`
Процесс будет выполнен после инициализации системы, независимо от уровня выполнения. Поле runlevels игнорируется.

`wait`
Процесс будет выполнен для указанных уровней выполнения, а init будет ждать его завершения, чтобы продолжить.

`respawn`
Процесс будет перезапущен, если он был завершен.

`ctrlaltdel`
Процесс будет выполнен, когда процесс init получит сигнал SIGINT, срабатывающий при нажатии последовательности клавиш Ctrl+Alt+Del.

Уровень выполнения по умолчанию — тот, который будет выбран, если в качестве параметра ядра не указано ничего другого — также определяется в файле /etc/inittab в записи `id:x:initdefault`. **X** — это номер уровня выполнения по умолчанию. **Этот номер никогда не должен быть равен 0 или 6**, поскольку это приведет к выключению или перезагрузке системы сразу после завершения процесса загрузки. Типичный файл `/etc/inittab` показан ниже:

```
# Default runlevel
id:3:initdefault:

# Configuration script executed during boot
si::sysinit:/etc/init.d/rcS

# Action taken on runlevel S (single user)
~:S:wait:/sbin/sulogin

# Configuration for each execution level
l0:0:wait:/etc/init.d/rc 0
l1:1:wait:/etc/init.d/rc 1
l2:2:wait:/etc/init.d/rc 2
l3:3:wait:/etc/init.d/rc 3
l4:4:wait:/etc/init.d/rc 4
l5:5:wait:/etc/init.d/rc 5
l6:6:wait:/etc/init.d/rc 6

# Action taken upon ctrl+alt+del keystroke
ca::ctrlaltdel:/sbin/shutdown -r now

# Enable consoles for runlevels 2 and 3
1:23:respawn:/sbin/getty tty1 VC linux
2:23:respawn:/sbin/getty tty2 VC linux
3:23:respawn:/sbin/getty tty3 VC linux
4:23:respawn:/sbin/getty tty4 VC linux

# For runlevel 3, also enable serial
# terminals ttyS0 and ttyS1 (modem) consoles
S0:3:respawn:/sbin/getty -L 9600 ttyS0 vt320
S1:3:respawn:/sbin/mgetty -x0 -D ttyS1
```

Команда `telinit q` должна выполняться каждый раз после изменения файла `/etc/inittab`. Аргумент `q (или Q)` сообщает `init` о необходимости перезагрузить конфигурацию. Такой шаг важен для предотвращения остановки системы из-за неправильной конфигурации в `/etc/inittab`.

Скрипты, используемые `init` для настройки каждого уровня выполнения, хранятся в каталоге `/etc/init.d/`. Каждый уровень выполнения имеет связанный каталог в /etc/ с именами /etc/rc0.d/, /etc/rc1.d/, /etc/rc2.d/ и т. д., со скриптами, которые должны быть выполнены при запуске соответствующего уровня выполнения. Поскольку один и тот же скрипт может использоваться разными уровнями выполнения, файлы в этих каталогах являются просто символическими ссылками на фактические скрипты в /etc/init.d/. Кроме того, первая буква имени файла ссылки в каталоге уровня выполнения указывает, должна ли служба быть запущена или завершена для соответствующего уровня выполнения. Имя файла ссылки, начинающееся с буквы `K`, определяет, что служба будет остановлена ​​при входе на уровень выполнения (`kill`). Начинаясь с буквы `S`, служба будет запущена при входе на уровень выполнения (`start`). Например, каталог `/etc/rc1.d/` будет иметь много ссылок на сетевые скрипты, начинающиеся с буквы `K`, учитывая, что уровень выполнения `1` является однопользовательским уровнем выполнения без сетевого подключения.

Команда `runlevel` показывает текущий уровень запуска для системы. Команда `runlevel` показывает два значения, первое — предыдущий уровень запуска, второе — текущий уровень запуска:
```
$ runlevel
N 5
```
![image](https://github.com/user-attachments/assets/e03eb954-5720-405c-b059-cff0eac59905)

Буква `N` в выводе показывает, что уровень выполнения не менялся с момента последней загрузки. В этом примере текущий уровень выполнения системы — уровень выполнения `5`.

Эту же программу `init` можно использовать для переключения между уровнями выполнения в работающей системе без необходимости перезагрузки. Команду `telinit` также можно использовать для переключения между уровнями выполнения. Например, команды `telinit 1`, `telinit s` или `telinit S` изменят систему на уровень выполнения `1`.



## systemd

В настоящее время systemd является наиболее широко используемым набором инструментов для управления системными ресурсами и службами, которые systemd называет единицами. Единица состоит из имени, типа и соответствующего файла конфигурации. Например, единица для процесса сервера httpd (например, веб-сервера Apache) будет httpd.service в дистрибутивах на основе Red Hat, а ее файл конфигурации также будет называться httpd.service (в дистрибутивах на основе Debian эта единица называется apache2.service).

Существует семь различных типов единиц systemd:

`service`  
Наиболее распространенный тип блока для активных системных ресурсов, которые могут быть инициированы, прерваны и перезагружены.

`socket`  
Тип блока сокета может быть сокетом файловой системы или сетевым сокетом. Все блоки сокета имеют соответствующий блок службы, загружаемый при получении сокетом запроса.

`device`  
Блок устройства связан с аппаратным устройством, идентифицированным ядром. Устройство будет восприниматься как блок systemd только в том случае, если для этой цели существует правило `udev`. Блок устройства может использоваться для разрешения зависимостей конфигурации при обнаружении определенного оборудования, учитывая, что свойства из правила `udev` могут использоваться в качестве параметров для блока устройства.

`mount`  
Блок монтирования — это определение точки монтирования в файловой системе, аналогичное записи в /etc/fstab.

`automount`  
Блок автоматического монтирования также является определением точки монтирования в файловой системе, но монтируется автоматически. Каждый блок автоматического монтирования имеет соответствующий блок монтирования, который инициируется при доступе к точке монтирования автоматического монтирования.

`target`  
Блок цели — это группа других блоков, управляемых как единый блок.

`snapshot`  
Модуль снимка — это сохраненное состояние менеджера systemd (доступно не во всех дистрибутивах Linux).

Основная команда для управления единицами `systemd` — `systemctl`. Команда `systemctl` используется для выполнения всех задач, связанных с активацией, деактивацией, выполнением, прерыванием, мониторингом и т. д. Например, для фиктивной единицы с именем unit.service наиболее распространенными действиями `systemctl` будут:

`systemctl start unit.service`  
Запускает модуль.

`systemctl stop unit.service`  
Останавливает модуль.

`systemctl restart unit.service`  
Перезапускает модуль.

`systemctl status unit.service`  
Показывает состояние модуля, включая то, запущен он или нет.

`systemctl is-active unit.service`  
Показывает активное состояние, если модуль запущен, или неактивное состояние в противном случае.

`systemctl enable unit.service`  
Включает модуль, то есть модуль будет загружен во время инициализации системы.

`systemctl disable unit.service`  
модуль не будет запускаться вместе с системой.

`systemctl is-enabled unit.service`  
Проверяет, запускается ли модуль вместе с системой. Ответ хранится в переменной $?. Значение 0 указывает, что модуль запускается вместе с системой, а значение 1 указывает, что модуль не запускается вместе с системой.

> Более новые установки systemd фактически выведут конфигурацию юнита для загрузки. Например:
```
systemctl is-enabled apparmor.service  
enabled
```

Если в системе нет других единиц с таким же именем, то суффикс после точки можно опустить. Если, например, есть только одна единица `httpd` типа `service`, то достаточно только httpd в качестве параметра единицы для `systemctl`.

Команда `systemctl` также может управлять системными целями. Например, единица `multi-user.target` объединяет все единицы, необходимые для многопользовательской системной среды. Она похожа на уровень выполнения номер 3 в системе, использующей `SysV`.

Команда `systemctl isolate` переключается между различными целями. Таким образом, чтобы вручную переключаться на многопользовательскую цель:
```
systemctl isolate multi-user.target
```

Существуют соответствующие цели для уровней запуска `SysV`, начиная с `runlevelO.target` и до `runlevel6.target`. Однако `systemd` не использует файл `/etc/inittab`. Чтобы изменить системную цель по умолчанию, можно добавить параметр `systemd.unit` в список параметров ядра. Например, чтобы использовать `multi-user.target` в качестве стандартной цели, параметр ядра должен быть `systemd.unit=multi-user.target`. Все параметры ядра можно сделать постоянными, изменив конфигурацию загрузчика.

```
systemctl set-default multi-user.target
```

Аналогичным образом вы можете определить цель загрузки вашей системы по умолчанию с помощью следующей команды:
```
systemctl get-default
graphical.target
```

Подобно системам, использующим SysV, цель по умолчанию никогда не должна указывать на shutdown.target, поскольку она соответствует уровню выполнения 0 (shutdown).

Файлы конфигурации, связанные с каждым юнитом, можно найти в каталоге `/lib/systemd/system/`. Команда `systemctl list-unit-files` выводит список всех доступных юнитов и показывает, включены ли они для запуска при загрузке системы. Параметр `--type` выберет только юниты для заданного типа, как в `systemctl list-unit-files --type=service` и `systemctl list-unit-files --type=target`.

Активные юниты или юниты, которые были активны во время текущего сеанса системы, можно перечислить с помощью команды `systemctl list-units`. Как и опция `systemctl list-unit-files`, команда `systemctl list-units --type=service` выберет только юниты типа service, а команда `systemctl list-units --type=target` выберет только юниты типа `target`.


`systemd` также отвечает за запуск и реагирование на события, связанные с питанием. Команда `systemctl suspend` переведет систему в режим низкого энергопотребления, сохраняя текущие данные в памяти. Команда `systemctl hibernate` скопирует все данные памяти на диск, поэтому текущее состояние системы можно будет восстановить после ее выключения. Действия, связанные с такими событиями, определены в файле `/etc/systemd/logind.conf` или в отдельных файлах внутри каталога `/etc/systemd/logind.conf.d/`. Однако эта функция systemd может использоваться только в том случае, если в системе не запущен другой менеджер питания, например демон `acpid`. Демон acpid является основным менеджером питания для Linux и позволяет более точно настраивать действия после событий, связанных с питанием, таких как закрытие крышки ноутбука, низкий уровень заряда батареи или уровень заряда батареи.


## Upstart

Скрипты инициализации, используемые `Upstart`, находятся в каталоге `/etc/init/`. Системные службы можно просмотреть с помощью команды `initctl list`, которая также показывает текущее состояние служб и, если доступно, их номер `PID`.
```
# initctl list
avahi-cups-reload stop/waiting
avahi-daemon start/running, process 1123
mountall-net stop/waiting
mountnfs-bootclean.sh start/running
nmbd start/running, process 3085
passwd stop/waiting
rc stop/waiting
rsyslog start/running, process 1095
tty4 start/running, process 1761
udev start/running, process 1073
upstart-udev-bridge start/running, process 1066
console-setup stop/waiting
irqbalance start/running, process 1842
plymouth-log stop/waiting
smbd start/running, process 1457
tty5 start/running, process 1764
failsafe stop/waiting
```

Каждое действие `Upstart` имеет свою собственную независимую команду. Например, команда `start` может быть использована для инициирования шестого виртуального терминала:
```
start tty6
```

Текущее состояние ресурса можно проверить с помощью команды `status`:
```
status tty6
```

А прерывание обслуживания осуществляется командой stop:
```
stop tty6
```

`Upstart` не использует файл `/etc/inittab` для определения уровней запуска, но устаревшие команды `runlevel` и `telinit` по-прежнему можно использовать для проверки и переключения между уровнями запуска.

> Upstart was developed for the Ubuntu Linux distribution to help facilitate parallel startup of processes. Ubuntu has stopped using Upstart since 2015 when it switched from Upstart to systemd.

### Выключение и перезагрузка

Очень традиционная команда, используемая для выключения или перезапуска системы, неудивительно называется `shutdown`. Команда `shutdown` добавляет дополнительные функции к процессу выключения: она автоматически уведомляет всех вошедших в систему пользователей предупреждающим сообщением в их сеансах оболочки, и новые входы в систему предотвращаются. Команда `shutdown` действует как посредник для процедур `SysV` или `systemd`, то есть она выполняет запрошенное действие, вызывая соответствующее действие в диспетчере служб, принятом системой.

После выполнения `shutdown` все процессы получают сигнал `SIGTERM`, за которым следует сигнал `SIGKILL`, затем система завершает работу или меняет свой уровень выполнения. По умолчанию, когда не используются ни параметры -h, ни -r, система переключается на уровень выполнения 1, то есть на однопользовательский режим. Чтобы изменить параметры по умолчанию для `shutdown`, команду следует выполнить со следующим синтаксисом:
```
shutdown [option] time [message]
```

Требуется только параметр `time`. Параметр `time` определяет, когда будет выполнено запрошенное действие, принимая следующие форматы:

`hh:mm`
Этот формат указывает время выполнения в часах и минутах.

`+m`
Этот формат указывает, сколько минут ждать перед выполнением.

`now или +0`
Этот формат определяет немедленное выполнение.

Параметр `message` — это текст предупреждения, отправляемый всем сеансам терминала вошедших в систему пользователей.

Реализация `SysV` позволяет ограничить пользователей, которые смогут перезапустить машину, нажав `Ctrl+Alt+Del`. Это возможно, если поместить опцию `-a` для команды `shutdown`, присутствующей в строке `ctrlaltdel` в файле `/etc/inittab`. Сделав это, только пользователи, чьи имена пользователей находятся в файле `/etc/shutdown.allow`, смогут перезапустить систему с помощью комбинации клавиш `Ctrl+Alt+Del`.

Команда `systemctl` также может использоваться для выключения или перезапуска машины в системах, использующих `systemd`. Для перезапуска системы следует использовать команду `systemctl reboot`. Для выключения системы следует использовать команду `systemctl poweroff`. Для запуска обеих команд требуются права `root`, поскольку обычные пользователи не могут выполнять такие процедуры.

Не все действия по обслуживанию требуют выключения или перезапуска системы. Однако, когда необходимо изменить состояние системы на однопользовательский режим, важно предупредить вошедших в систему пользователей, чтобы они не пострадали от внезапного прекращения их действий.

Подобно тому, что делает команда `shutdown` при выключении или перезапуске системы, команда `wall` может отправлять сообщение в терминальные сеансы всех вошедших в систему пользователей. Для этого системному администратору нужно только предоставить файл или напрямую записать сообщение в качестве параметра команды `wall`.
```
wall "The system will be restarted in 10 minutes."
```

Сообщение будет передано всем пользователям, которые в данный момент вошли в систему. Чтобы увидеть всех вошедших в систему пользователей, выполните команду `w` или `who`. Чтобы подавить баннер и отображать только вводимый вами текст для вошедших в систему пользователей, вызовите команду с параметром `-n( —nobanner)`:
```
wall -n "The system will be restarted in 10 minutes."
```

## Guided Exercises

**1. Как можно использовать команду telinit для перезагрузки системы?**  
`telinit 6`

**2. Что произойдет со службами, связанными с файлом /etc/rc1.d/K90network, когда система перейдет на уровень выполнения 1?**  
`Службы будет отключена и не активна`

**3. Как пользователь может проверить, запущен ли модуль sshd.service, используя команду systemctl?**  
`systemctl status sshd.service или systemctl is-active sshd.service`

**4. В системе на основе systemd какую команду необходимо выполнить, чтобы включить активацию модуля sshd.service во время инициализации системы?**  
`systemctl enable sshd.service`
















