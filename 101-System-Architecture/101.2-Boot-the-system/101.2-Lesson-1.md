## Determine and configure hardware settings

### <a name='toc'>Содержание</a>

1. [BIOS или UEFI](#1)
2. [The Bootloader (Загрузчик)](#2)
3. [System Initialization (Инициализация системы)](#3)
4. [Initialization Inspection (Инициализация Инспекции)](#4)
5. [Guided Exercises](#5)
6. 
7. [Guided Exercises (Упражнения с инструкциями)](#6)
8. [Summary (Резюме)](#7)

### Введение

Чтобы управлять машиной, основной компонент операционной системы — ядро ​​— должен быть загружен программой, называемой загрузчиком, которая сама загружается предустановленной прошивкой, такой как BIOS или UEFI. Загрузчик можно настроить для передачи параметров ядру, например, какой раздел содержит корневую файловую систему или в каком режиме должна выполняться операционная система. После загрузки ядро ​​продолжает процесс загрузки, идентифицируя и настраивая оборудование. Наконец, ядро ​​вызывает утилиту, отвечающую за запуск и управление службами системы.

> В некоторых дистрибутивах Linux для выполнения команд в этом уроке могут потребоваться права root.

### [[⬆]](#toc) <a name='1'>BIOS или UEFI</a>

Процедуры, выполняемые машинами x86 для запуска загрузчика, различаются в зависимости от того, используют ли они BIOS или UEFI. BIOS, сокращение от Basic Input/Output System, представляет собой программу, хранящуюся в энергонезависимой микросхеме памяти, подключенной к материнской плате, которая выполняется каждый раз при включении компьютера. Этот тип программы называется встроенным ПО, и ее место хранения отделено от других устройств хранения, которые могут быть в системе. BIOS предполагает, что первые 440 байтов в первом устройстве хранения — в соответствии с порядком, определенным в утилите конфигурации BIOS — являются первым этапом загрузчика (также называемым bootstrap). Первые 512 байтов устройства хранения называются MBR (Master Boot Record) устройств хранения, использующих стандартную схему разделов DOS, и, в дополнение к первому этапу загрузчика, содержат таблицу разделов. Если MBR не содержит правильных данных, система не сможет загрузиться, если не будет использован альтернативный метод.

В целом, предварительные этапы загрузки системы, оснащенной BIOS, следующие:

1. Процесс POST (самотестирование при включении питания) выполняется для выявления простых аппаратных сбоев сразу после включения машины.
2. BIOS активирует основные компоненты для загрузки системы, такие как видеовыход, клавиатура и носители информации.
3. BIOS загружает первый этап загрузчика из MBR (первые 440 байт первого устройства, как определено в утилите конфигурации BIOS).
4. Первый этап загрузчика вызывает второй этап загрузчика, отвечающий за представление параметров загрузки и загрузку ядра.

UEFI, сокращение от Unified Extensible Firmware Interface, отличается от BIOS в некоторых ключевых моментах. Как и BIOS, UEFI также является прошивкой, но она может идентифицировать разделы и считывать множество файловых систем, обнаруженных в них. UEFI не полагается на MBR, принимая во внимание только настройки, хранящиеся в его энергонезависимой памяти (NVRAM), подключенной к материнской плате. Эти определения указывают местоположение совместимых с UEFI программ, называемых приложениями EFI, которые будут выполняться автоматически или вызываться из меню загрузки. Приложения EFI могут быть загрузчиками, селекторами операционных систем, инструментами для диагностики и ремонта системы и т. д. Они должны находиться в обычном разделе устройства хранения данных и в совместимой файловой системе. Стандартными совместимыми файловыми системами являются FAT12, FAT16 и FAT32 для блочных устройств и ISO-9660 для оптических носителей. Такой подход позволяет реализовать гораздо более сложные инструменты, чем те, которые возможны с BIOS.

Раздел, содержащий приложения EFI, называется системным разделом EFI или просто ESP. Этот раздел не должен использоваться совместно с другими системными файловыми системами, такими как корневая файловая система или файловые системы пользовательских данных. Каталог EFI в разделе ESP содержит приложения, на которые указывают записи, сохраненные в NVRAM.

В общем, шаги по загрузке операционной системы в системе с UEFI следующие:

1. Процесс POST (самотестирование при включении питания) выполняется для выявления простых аппаратных сбоев сразу после включения машины.
2. UEFI активирует основные компоненты для загрузки системы, такие как видеовыход, клавиатура и носители информации.
3. Прошивка UEFI считывает определения, хранящиеся в NVRAM, для выполнения предопределенного приложения EFI, хранящегося в файловой системе раздела ESP. Обычно предопределенное приложение EFI является загрузчиком.
4. Если предопределенное приложение EFI является загрузчиком, оно загрузит ядро ​​для запуска операционной системы.

Стандарт UEFI также поддерживает функцию, называемую _Secure Boot_, которая позволяет выполнять только подписанные приложения EFI, то есть приложения EFI, авторизованные производителем оборудования. Эта функция повышает защиту от вредоносного ПО, но может затруднить установку операционных систем, не покрываемых гарантией производителя.


### [[⬆]](#toc) <a name='2'>The Bootloader (Загрузчик)</a>

Самый популярный загрузчик для Linux в архитектуре x86 — GRUB (Grand Unified Bootloader). Как только он вызывается BIOS или UEFI, GRUB отображает список операционных систем, доступных для загрузки. Иногда список не появляется автоматически, но его можно вызвать, нажав Shift во время вызова GRUB BIOS. В системах UEFI вместо этого следует использовать клавишу Esc.

В меню GRUB можно выбрать, какое из установленных ядер следует загрузить, и передать ему новые параметры. Большинство параметров ядра следуют шаблону option=value. Вот некоторые из наиболее полезных параметров ядра:

`acpi`  
Включает/отключает поддержку ACPI. `acpi=off` отключит поддержку ACPI.

`init`  
Устанавливает альтернативный системный инициатор. Например, init=/bin/bash установит оболочку Bash в качестве инициатора. Это означает, что сеанс оболочки начнется сразу после процесса загрузки ядра.

`systemd.unit`  
Устанавливает активируемую цель systemd. Например, systemd.unit=graphical.target. Systemd также принимает числовые уровни выполнения, определенные для SysV. Например, чтобы активировать уровень выполнения 1, необходимо включить только число 1 или букву S (сокращение от «single») в качестве параметра ядра.

`mem`  
Устанавливает объем доступной оперативной памяти для системы. Этот параметр полезен для виртуальных машин, чтобы ограничить объем оперативной памяти, доступный каждому гостю. Использование mem=512M ограничит объем доступной оперативной памяти для конкретной гостевой системы до 512 мегабайт.

`maxcpus`  
Ограничивает количество процессоров (или ядер процессора), видимых системе в симметричных многопроцессорных машинах. Он также полезен для виртуальных машин. Значение 0 отключает поддержку многопроцессорных машин и имеет тот же эффект, что и параметр ядра nosmp. Параметр maxcpus=2 ограничит количество процессоров, доступных операционной системе, двумя.

`quiet`  
Скрывает большинство сообщений загрузки.

`vga`  
Выбирает видеорежим. Параметр vga=ask покажет список доступных режимов для выбора.

`root`  
Устанавливает корневой раздел, отличный от предварительно настроенного в загрузчике. Например, root=/dev/sda3.

`rootflags`  
Параметры монтирования для корневой файловой системы.

`ro`  
Делает начальное монтирование корневой файловой системы доступным только для чтения.

`rw`  
Разрешает запись в корневую файловую систему во время начального монтирования.

Изменение параметров ядра обычно не требуется, но может быть полезно для обнаружения и решения проблем, связанных с операционной системой. Параметры ядра должны быть добавлены в файл /etc/default/grub в строке GRUB_CMDLINE_LINUX, чтобы сделать их постоянными при перезагрузках. Новый файл конфигурации для загрузчика должен быть сгенерирован каждый раз при изменении /etc/default/grub, что выполняется командой grub-mkconfig -o /boot/grub/grub.cfg. После запуска операционной системы параметры ядра, используемые для загрузки текущего сеанса, доступны для чтения в файле /proc/cmdline.

> Настройка GRUB будет рассмотрена более подробно в следующем уроке..



### [[⬆]](#toc) <a name='3'>System Initialization (Инициализация системы)</a>

Помимо ядра, операционная система зависит от других компонентов, которые обеспечивают ожидаемые функции. Многие из этих компонентов загружаются во время процесса инициализации системы, варьируясь от простых сценариев оболочки до более сложных служебных программ. Скрипты часто используются для выполнения краткосрочных задач, которые будут запускаться и завершаться во время процесса инициализации системы. Службы, также известные как демоны, могут быть активны все время, поскольку они могут отвечать за внутренние аспекты операционной системы.

Разнообразие способов, которыми сценарии запуска и демоны с самыми разными характеристиками могут быть встроены в дистрибутив Linux, огромно, что исторически препятствовало разработке единого решения, которое отвечало бы ожиданиям сопровождающих и пользователей всех дистрибутивов Linux. Однако любой инструмент, который сопровождающие дистрибутива выбрали для выполнения этой функции, по крайней мере сможет запускать, останавливать и перезапускать системные службы. Эти действия часто выполняются самой системой после обновления программного обеспечения, например, но системному администратору почти всегда нужно будет вручную перезапускать службу после внесения изменений в ее файл конфигурации.

Также системному администратору удобно иметь возможность активировать определенный набор демонов в зависимости от обстоятельств. Например, должна быть возможность запускать только минимальный набор служб для выполнения задач по обслуживанию системы.

> Строго говоря, операционная система — это просто ядро ​​и его компоненты, которые контролируют оборудование и управляют всеми процессами. Однако термин «операционная система» принято использовать более свободно, обозначая целую группу отдельных программ, составляющих программную среду, в которой пользователь может выполнять основные вычислительные задачи.

Инициализация операционной системы начинается, когда загрузчик загружает ядро ​​в ОЗУ. Затем ядро ​​берет на себя управление ЦП и начинает обнаруживать и настраивать основные аспекты операционной системы, такие как базовая конфигурация оборудования и адресация памяти.

Затем ядро ​​открывает initramfs (_начальную файловую систему ОЗУ_). Initramfs — это архив, содержащий файловую систему, используемую как временная корневая файловая система во время процесса загрузки. Основное назначение файла `initramfs` — предоставить необходимые модули, чтобы ядро ​​могло получить доступ к «реальной» корневой файловой системе операционной системы.

Как только корневая файловая система станет доступна, ядро ​​смонтирует все файловые системы, настроенные в `/etc/fstab`, а затем выполнит первую программу — утилиту с именем `init`. Программа `init` отвечает за запуск всех скриптов инициализации и системных демонов. Существуют различные реализации таких системных инициаторов, помимо традиционного `init`, такие как `systemd` и `Upstart`. После загрузки программы `init initramfs` удаляется из оперативной памяти.

`Стандарт SysV`
Менеджер служб, основанный на стандарте SysVinit, контролирует, какие демоны и ресурсы будут доступны, используя концепцию уровней выполнения. Уровни выполнения пронумерованы от 0 до 6 и разработаны разработчиками дистрибутивов для выполнения определенных целей. Единственными определениями уровней выполнения, общими для всех дистрибутивов, являются уровни выполнения 0, 1 и 6.

`systemd`
systemd — это современный менеджер систем и служб с уровнем совместимости для команд и уровней выполнения SysV. systemd имеет параллельную структуру, использует сокеты и D-Bus для активации служб, выполнения демонов по требованию, мониторинга процессов с помощью cgroups, поддержки снимков, восстановления системных сеансов, управления точками монтирования и управления службами на основе зависимостей. В последние годы большинство основных дистрибутивов Linux постепенно приняли systemd в качестве своего системного менеджера по умолчанию.

`Upstart`
Как и systemd, Upstart является заменой init. Цель Upstart — ускорить процесс загрузки путем распараллеливания процесса загрузки системных служб. Upstart использовался в дистрибутивах на базе Ubuntu в прошлых выпусках, но сегодня уступил место systemd.



### [[⬆]](#toc) <a name='4'>Initialization Inspection (Инициализация Инспекции)</a>

Ошибки могут возникать во время процесса загрузки, но они могут быть не настолько критичны, чтобы полностью остановить операционную систему. Тем не менее, эти ошибки могут поставить под угрозу ожидаемое поведение системы. Все ошибки приводят к сообщениям, которые могут быть использованы для будущих расследований, поскольку они содержат ценную информацию о том, когда и как произошла ошибка. Даже если сообщения об ошибках не генерируются, информация, собранная во время процесса загрузки, может быть полезна для настройки и конфигурации.

Пространство памяти, в котором ядро ​​хранит свои сообщения, включая сообщения загрузки, называется кольцевым буфером ядра. Сообщения хранятся в кольцевом буфере ядра, даже если они не отображаются во время процесса инициализации, например, когда вместо этого отображается анимация. Однако кольцевой буфер ядра теряет все сообщения при выключении системы или при выполнении команды dmesg --clear. Без параметров команда dmesg отображает текущие сообщения в кольцевом буфере ядра:

```
dmesg
[    4.287300] mei_hdcp 0000:00:16.0-b638ab7e-94e2-4ea2-a552-d1c54b627f04: bound 0000:00:02.0 (ops i915_hdcp_component_ops [i915])
[    4.289408] e1000e 0000:00:1f.6 0000:00:1f.6 (uninitialized): registered PHC clock
[    4.316541] input: HP WMI hotkeys as /devices/virtual/input/input8
[    4.335129] Adding 24059900k swap on /dev/nvme0n1p2.  Priority:-2 extents:1 across:24059900k SSFS
[    4.397605] EXT4-fs (nvme0n1p4): mounted filesystem with ordered data mode. Quota mode: writeback.
[    4.399989] e1000e 0000:00:1f.6 eth0: (PCI Express:2.5GT/s:Width x1) 30:13:8b:7c:9d:ad
[    4.399992] e1000e 0000:00:1f.6 eth0: Intel(R) PRO/1000 Network Connection
[    4.400103] e1000e 0000:00:1f.6 eth0: MAC: 15, PHY: 12, PBA No: FFFFFF-0
```

Вывод `dmesg` может быть длиной в сотни строк, поэтому предыдущий листинг содержит только отрывок, показывающий, как ядро ​​вызывает диспетчер служб systemd. Значения в начале строк — это количество секунд относительно начала загрузки ядра.

В системах на базе `systemd` команда `journalctl` покажет сообщения инициализации с параметрами `-b`, `--boot`, `-k` или `--dmesg`. Команда `journalctl --list-boots` показывает список номеров загрузок относительно текущей загрузки, их идентификационный хэш и временные метки первого и последнего соответствующих сообщений:

```
journalctl --list-boots
 -24 6089df11bfa94a639ee9a38c4eefd1d3 Wed 2024-11-06 19:03:58 MSK—Wed 2024-11-06 19:25:14 MSK
 -23 2cf7c22a599949499cf403789e8f6ff5 Wed 2024-11-06 19:25:29 MSK—Wed 2024-11-06 18:00:52 MSK
 -22 be3d6c7f71eb463c8bb52178bdf64a40 Thu 2024-11-07 08:32:20 MSK—Thu 2024-11-07 09:03:02 MSK
 -21 d7d8b23aed5843b6983f8556c4b95cfb Thu 2024-11-07 09:03:19 MSK—Thu 2024-11-07 09:06:15 MSK
 -20 994005e321224f97a48c301373254c8e Thu 2024-11-07 09:06:29 MSK—Thu 2024-11-07 15:54:03 MSK
 -19 1a4738bf1dc04321a3de3e6ef5743311 Thu 2024-11-07 15:54:20 MSK—Thu 2024-11-07 16:10:34 MSK
 -18 0bb229d4332649faa703bb7aa87c0167 Thu 2024-11-07 16:11:02 MSK—Thu 2024-11-07 18:01:07 MSK
 -17 1c5868d1e3a64e62b06bb5f3f5864b09 Fri 2024-11-08 08:41:28 MSK—Fri 2024-11-08 09:03:07 MSK
 -16 2a1017e3ec0142d59703ffc799e723aa Fri 2024-11-08 09:03:23 MSK—Fri 2024-11-08 09:05:04 MSK
 -15 3ac2d1db6a964e7eab75dc3d992a0b3a Fri 2024-11-08 09:05:21 MSK—Fri 2024-11-08 11:23:38 MSK
 -14 197b5909ccec4ee08147e8d40e02191a Fri 2024-11-08 11:23:55 MSK—Fri 2024-11-08 11:24:38 MSK
 -13 bad7bc143edc4c769c4a0843c8df8ae8 Fri 2024-11-08 11:24:55 MSK—Fri 2024-11-08 11:35:00 MSK
 -12 47aa74eb611b4ab5ae25764b944a1e38 Fri 2024-11-08 11:35:42 MSK—Fri 2024-11-08 15:12:02 MSK
 -11 e1515403bf644ebd9795a81fc89d0598 Fri 2024-11-08 15:12:22 MSK—Fri 2024-11-08 18:08:24 MSK
 -10 e459f79b23b348eab3d72e29c3deff6b Tue 2024-11-12 12:20:26 MSK—Tue 2024-11-12 12:28:59 MSK
  -9 0bf594980fd04002b7a411b1bdc8d222 Mon 2024-11-18 08:58:06 MSK—Mon 2024-11-18 14:27:00 MSK
  -8 344f173e2f0d4427b371dff589042614 Mon 2024-11-18 14:27:16 MSK—Mon 2024-11-18 14:28:04 MSK
  -7 71d55070f2c24741aec525e62b07afcf Mon 2024-11-18 14:28:20 MSK—Mon 2024-11-18 15:50:14 MSK
  -6 2d97947604cf4e9894147ed6dcea9bb4 Mon 2024-11-18 15:50:31 MSK—Mon 2024-11-18 15:51:14 MSK
  -5 13e0ce121c334d72b5ebc65d399ac339 Mon 2024-11-18 15:51:30 MSK—Mon 2024-11-18 17:10:58 MSK
  -4 5250e68e762c49b79864daa334d215b6 Mon 2024-11-18 17:11:15 MSK—Mon 2024-11-18 18:01:08 MSK
  -3 c25716cba5b944bc9e2916f65224e651 Tue 2024-11-19 08:54:58 MSK—Tue 2024-11-19 17:25:18 MSK
  -2 e089caf3d7f14ee0ac29ed5a4eea20af Tue 2024-11-19 17:25:41 MSK—Wed 2024-11-20 16:37:14 MSK
  -1 fad83a014f80434f9f42bc1f4e2a788e Wed 2024-11-20 16:37:50 MSK—Thu 2024-11-21 11:04:44 MSK
   0 9709546979ff4beca21949a07fb817c8 Thu 2024-11-21 11:05:01 MSK—Fri 2024-11-22 17:02:03 MSK
```
Журналы предыдущей инициализации также хранятся в системах на основе systemd, поэтому сообщения из предыдущих сеансов операционной системы все еще могут быть просмотрены. Если указаны параметры `-b 0` или `--boot=0`, то будут показаны сообщения для текущей загрузки. Параметры `-b -1` или `--boot=-1` покажут сообщения из предыдущей инициализации. Параметры `-b -2` или `--boot=-2` покажут сообщения из инициализации до этого и так далее. Следующий фрагмент показывает, как ядро ​​вызывает диспетчер служб `systemd` для последнего процесса инициализации:

```
journalctl -b 0
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: microcode: microcode updated early to revision 0x35, date = 2023-12-05
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: Linux version 6.1.79-un-def-alt1 (builder@localhost.localdomain) (gcc-10 (GCC) 10.3.1 20210703 (ALT Sisyphus 10.3.1-alt2), GNU ld (GNU Binutils) 2.35>
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: Command line: BOOT_IMAGE=/boot/vmlinuz-un-def root=UUID=279b7bd5-0d03-4ff2-b5ff-1512f5a5978b ro resume=/dev/disk/by-uuid/ed49a15e-50b0-4f97-aa01-bf50>
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: KERNEL supported cpus:
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel:   Intel GenuineIntel
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel:   AMD AuthenticAMD
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel:   Hygon HygonGenuine
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel:   Centaur CentaurHauls
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel:   zhaoxin   Shanghai  
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: x86/split lock detection: #AC: crashing the kernel on kernel split_locks and warning on user-space split_locks
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: BIOS-provided physical RAM map:
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: BIOS-e820: [mem 0x0000000000000000-0x000000000009efff] usable
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: BIOS-e820: [mem 0x000000000009f000-0x00000000000fffff] reserved
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: BIOS-e820: [mem 0x0000000000100000-0x000000006bdddfff] usable
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: BIOS-e820: [mem 0x000000006bdde000-0x000000006c2ddfff] type 20
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: BIOS-e820: [mem 0x000000006c2de000-0x000000006f93dfff] reserved
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: BIOS-e820: [mem 0x000000006f93e000-0x000000006fb3dfff] ACPI NVS
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: BIOS-e820: [mem 0x000000006fb3e000-0x000000006fbfefff] ACPI data
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: BIOS-e820: [mem 0x000000006fbff000-0x000000006fbfffff] usable
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: BIOS-e820: [mem 0x000000006fc00000-0x0000000075ffffff] reserved
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: BIOS-e820: [mem 0x0000000077600000-0x00000000777fffff] reserved
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: BIOS-e820: [mem 0x0000000078000000-0x00000000807fffff] reserved
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: BIOS-e820: [mem 0x00000000c0000000-0x00000000cfffffff] reserved
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: BIOS-e820: [mem 0x00000000fed20000-0x00000000fed7ffff] reserved
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: BIOS-e820: [mem 0x00000000ff000000-0x00000000ffffffff] reserved
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: BIOS-e820: [mem 0x0000000100000000-0x000000047f7fffff] usable
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: NX (Execute Disable) protection: active
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: efi: EFI v2.70 by HP
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: efi: ACPI=0x6fbfe000 ACPI 2.0=0x6fbfe014 TPMFinalLog=0x6faba000 SMBIOS=0x6c549000 ESRT=0x6c5a9118 MEMATTR=0x6023e018 
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: SMBIOS 3.6 present.
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: DMI: HP HP Pro Mini 400 G9 Desktop PC/8955, BIOS U23 Ver. 02.13.02 02/02/2024
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: tsc: Detected 2000.000 MHz processor
ноя 21 11:05:01 ptrt-ws-0170.corp.cosmosgroup.ru kernel: tsc: Detected 1996.800 MHz TS
```

Инициализация и другие сообщения, выдаваемые операционной системой, хранятся в файлах внутри каталога `/var/log/`. Если происходит критическая ошибка и операционная система не может продолжить процесс инициализации после загрузки ядра и `initramfs`, можно использовать альтернативный загрузочный носитель для запуска системы и доступа к соответствующей файловой системе. Затем можно выполнить поиск файлов в каталоге `/var/log/` на предмет возможных причин прерывания процесса загрузки. Параметры `-D` или `--directory` команды `journalctl` можно использовать для чтения сообщений журнала в каталогах, отличных от `/var/log/journal/`, который является расположением по умолчанию для сообщений журнала `systemd`. Поскольку сообщения журнала `systemd` не хранятся в виде необработанного текста, для их чтения требуется команда `journalctl`.



### [[⬆]](#toc) <a name='5'>Guided Exercises</a>

1. Где на машине с прошивкой BIOS находится двоичный файл начальной загрузки?  
**Ответ:** В MBR первого устройства хранения данных, как определено в утилите конфигурации BIOS.
3. Прошивка UEFI поддерживает расширенные функции, предоставляемые внешними программами, называемыми приложениями EFI. Однако эти приложения имеют свое собственное особое расположение. Где в системе будут располагаться приложения EFI?
4. Загрузчики позволяют передавать пользовательские параметры ядра перед его загрузкой. Предположим, что система не может загрузиться из-за неверного расположения корневой файловой системы. Как правильная корневая файловая система, расположенная в /dev/sda3, будет передана в качестве параметра ядру?
5. The boot process of a Linux machine ends up with the following message:
```
ALERT! /dev/sda3 does not exist. Dropping to a shell!
```
Какова вероятная причина этой проблемы?














