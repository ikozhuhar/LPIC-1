## Архитектура системы

С первых лет электронных вычислений производители компьютеров для бизнеса и персональных компьютеров интегрировали в свои машины различные аппаратные части, которые, в свою очередь, должны поддерживаться операционной системой. Это может быть непосильной задачей с точки зрения разработчика операционной системы, если только отрасль не установит стандарты для наборов инструкций и связи с устройствами. Подобно стандартизированному слою абстракции, предоставляемому операционной системой приложению, эти стандарты упрощают написание и поддержку операционной системы, не привязанной к конкретной модели оборудования. Однако сложность интегрированного базового оборудования иногда требует корректировки того, как ресурсы должны быть представлены операционной системе, чтобы ее можно было установить и правильно функционировать.

Некоторые из этих корректировок можно выполнить даже без установленной операционной системы. Большинство машин предлагают утилиту настройки, которую можно запустить при включении машины. До середины 2000-х годов утилита настройки была реализована в BIOS (Basic Input/Output System), стандарте для прошивки, содержащей основные процедуры настройки, имеющиеся в материнских платах x86. С конца первого десятилетия 2000-х годов машины на базе архитектуры x86 начали заменять BIOS новой реализацией под названием UEFI (Unified Extensible Firmware Interface), которая имеет более сложные функции для идентификации, тестирования, настройки и обновления прошивки. Несмотря на изменение, утилиту настройки все еще часто называют BIOS, поскольку обе реализации выполняют одну и ту же основную задачу

### Активация устройства

Утилита настройки системы отображается после нажатия определенной клавиши при включении компьютера. Выбор клавиши для нажатия зависит от производителя, но обычно это `Del` или одна из функциональных клавиш, например `F2` или `F12`. Сочетание клавиш часто отображается на экране включения питания.

В утилите настройки BIOS можно включать и отключать интегрированные периферийные устройства, активировать базовую защиту от ошибок и изменять аппаратные настройки, такие как IRQ (запрос прерывания) и DMA (прямой доступ к памяти). Изменение этих настроек редко требуется на современных компьютерах, но может потребоваться внести коррективы для решения определенных проблем. Например, существуют технологии ОЗУ, совместимые с более высокой скоростью передачи данных, чем значения по умолчанию, поэтому рекомендуется изменить ее на значения, указанные производителем. Некоторые ЦП предлагают функции, которые могут не потребоваться для конкретной установки и могут быть отключены. Отключенные функции снизят энергопотребление и могут повысить защиту системы, поскольку функции ЦП, содержащие известные ошибки, также могут быть отключены.

Если машина оснащена множеством устройств хранения данных, важно определить, какое из них имеет правильный загрузчик и должно быть первым в порядке загрузки устройств. Операционная система может не загрузиться, если неправильное устройство стоит первым в списке проверки загрузки BIOS.

### Проверка устройств в Linux

После того, как устройства правильно идентифицированы, операционная система должна связать соответствующие программные компоненты, требуемые ими. Когда аппаратная функция не работает должным образом, важно определить, где именно происходит проблема. Когда часть оборудования не обнаруживается операционной системой, скорее всего, эта часть — или порт, к которому она подключена — неисправны. Когда часть оборудования обнаружена правильно, но все равно не работает должным образом, может быть проблема на стороне операционной системы. Поэтому одним из первых шагов при решении проблем, связанных с оборудованием, является проверка того, правильно ли операционная система обнаруживает устройство.

Существует два основных способа определения аппаратных ресурсов в системе Linux: использовать специализированные команды или читать определенные файлы внутри специальных файловых систем

### Команды для проверки

Две основные команды для идентификации подключенных устройств в системе Linux:

`lspci`  
Показывает все устройства, подключенные в данный момент к шине PCI (Peripheral Component Interconnect). Устройства PCI могут быть либо компонентом, подключенным к материнской плате, например, контроллером диска, либо платой расширения, вставленной в слот PCI, например, внешней видеокартой.

`lsusb`  
Выводит список устройств USB (Universal Serial Bus), подключенных в данный момент к машине. Хотя существуют USB-устройства практически для любых мыслимых целей, интерфейс USB в основном используется для подключения устройств ввода — клавиатур, указывающих устройств — и съемных носителей информации.

Вывод команд `lspci` и `lsusb` состоит из списка всех устройств PCI и USB, идентифицированных операционной системой. Однако устройство может быть еще не полностью работоспособным, поскольку для каждой аппаратной части требуется программный компонент для управления соответствующим устройством. Этот программный компонент называется **модулем ядра** и может быть частью официального ядра Linux или добавляться отдельно из других источников.

**Модули ядра Linux**, связанные с аппаратными устройствами, также называются **драйверами**, как и в других операционных системах. Однако драйверы для Linux не всегда поставляются производителем устройства. Хотя некоторые производители предоставляют собственные двоичные драйверы для отдельной установки, многие драйверы пишутся независимыми разработчиками. Исторически сложилось так, что части, работающие, например, в Windows, могут не иметь соответствующего модуля ядра для Linux. В настоящее время операционные системы на базе Linux имеют сильную аппаратную поддержку, и большинство устройств работают без проблем.

Команды, напрямую связанные с оборудованием, часто **требуют прав root** для выполнения или будут показывать только ограниченную информацию при выполнении обычным пользователем, поэтому может потребоваться войти в систему как root или выполнить команду с помощью sudo.

Например, следующий вывод команды `lspci` показывает несколько идентифицированных устройств:
```
lspci
00:02.0 VGA compatible controller: Intel Corporation Alder Lake-S GT1 [UHD Graphics 770] (rev 0c)
00:14.0 USB controller: Intel Corporation Alder Lake-S PCH USB 3.2 Gen 2x2 XHCI Controller (rev 11)
00:14.2 RAM memory: Intel Corporation Alder Lake-S PCH Shared SRAM (rev 11)
00:16.0 Communication controller: Intel Corporation Alder Lake-S PCH HECI Controller #1 (rev 11)
00:16.3 Serial controller: Intel Corporation Device 7aeb (rev 11)
00:17.0 SATA controller: Intel Corporation Alder Lake-S PCH SATA Controller [AHCI Mode] (rev 11)
00:1f.3 Audio device: Intel Corporation Alder Lake-S HD Audio Controller (rev 11)
00:1f.4 SMBus: Intel Corporation Alder Lake-S PCH SMBus Controller (rev 11)
00:1f.5 Serial bus controller: Intel Corporation Alder Lake-S PCH SPI Controller (rev 11)
00:1f.6 Ethernet controller: Intel Corporation Ethernet Connection (17) I219-LM (rev 11)
01:00.0 Non-Volatile memory controller: Samsung Electronics Co Ltd NVMe SSD Controller PM9B1 (DRAM-less) (rev 02)
02:00.0 Network controller: Realtek Semiconductor Co., Ltd. RTL8852BE PCIe 802.11ax Wireless Network Controller

```

Вывод таких команд может быть длиной в десятки строк, поэтому предыдущий и следующий примеры содержат только интересующие нас разделы. Шестнадцатеричные числа в начале каждой строки являются уникальными адресами соответствующего устройства PCI. Команда `lspci` показывает больше подробностей о конкретном устройстве, если его адрес указан с опцией `-s`, сопровождаемой опцией `-v`:
```
lspci -s 02:00.0 -v
02:00.0 Network controller: Realtek Semiconductor Co., Ltd. RTL8852BE PCIe 802.11ax Wireless Network Controller
	Subsystem: Hewlett-Packard Company Device 88e3
	Flags: bus master, fast devsel, latency 0, IRQ 143
	I/O ports at 3000 [size=256]
	Memory at 80800000 (64-bit, non-prefetchable) [size=1M]
	Capabilities: <access denied>
	Kernel driver in use: rtw89_8852be

```

Теперь вывод показывает гораздо больше подробностей об устройстве по адресу 02:00.0. Это сетевой контроллер, внутреннее имя которого — Realtek Semiconductor Co., Ltd. RTL8852BE PCIe 802.11ax Wireless. Подсистема связана с маркой и моделью устройства — Hewlett-Packard Company Device 88e3 — и может быть полезна для диагностических целей.

Модуль ядра можно определить в строке **kernel driver in use**, которая показывает модуль rtw89_8852be. Из всей собранной информации можно сделать правильное предположение, что:

1. Устройство было идентифицировано.
2. Был загружен соответствующий модуль ядра.
3. Устройство должно быть готово к использованию.

Другой способ проверить, какой модуль ядра используется для указанного устройства, предоставляется опцией `-k`, доступной в более поздних версиях `lspci`:
```
lspci -s 02:00.0 -k
02:00.0 Network controller: Realtek Semiconductor Co., Ltd. RTL8852BE PCIe 802.11ax Wireless Network Controller
	Subsystem: Hewlett-Packard Company Device 88e3
	Kernel driver in use: rtw89_8852be
```

Команда `lsusb` похожа на `lspci`, но выводит исключительно информацию о USB:

```
lsusb
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 001 Device 003: ID 0461:554a Primax Electronics, Ltd HP 125 Wired Keyboard
Bus 001 Device 004: ID 0bda:b85c Realtek Semiconductor Corp. Bluetooth Radio
Bus 001 Device 002: ID 0d62:12ec Darfon Electronics Corp. HP 125 USB Optical Mouse
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
```

Команда `lsusb` показывает доступные каналы USB и подключенные к ним устройства. Как и в случае с `lspci`, опция `-v` отображает более подробный вывод. Конкретное устройство можно выбрать для проверки, указав его идентификатор опции `-d`:

```
lsusb -v -d 0bda:b85c

Bus 001 Device 004: ID 0bda:b85c Realtek Semiconductor Corp. Bluetooth Radio
Couldn't open device, some information will be missing
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               1.00
  bDeviceClass          224 Wireless
  bDeviceSubClass         1 Radio Frequency
  bDeviceProtocol         1 Bluetooth
  bMaxPacketSize0        64
  idVendor           0x0bda Realtek Semiconductor Corp.
  idProduct          0xb85c 
  bcdDevice            0.00
  iManufacturer           1 Realtek
  iProduct                2 Bluetooth Radio
  iSerial                 3 00e04c000001
  bNumConfigurations      1
```

С опцией -t команда lsusb отображает текущие сопоставления USB-устройств в виде иерархического дерева:

```
lsusb -t
/:  Bus 02.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/9p, 20000M/x2
/:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/16p, 480M
    |__ Port 1: Dev 2, If 0, Class=Human Interface Device, Driver=usbhid, 1.5M
    |__ Port 2: Dev 3, If 0, Class=Human Interface Device, Driver=usbhid, 1.5M
    |__ Port 2: Dev 3, If 1, Class=Human Interface Device, Driver=usbhid, 1.5M
    |__ Port 14: Dev 4, If 0, Class=Wireless, Driver=btusb, 12M
    |__ Port 14: Dev 4, If 1, Class=Wireless, Driver=btusb, 12M
```

Возможно, не все устройства имеют соответствующие модули, связанные с ними. Связь с некоторыми устройствами может осуществляться приложением напрямую, без посредничества, предоставляемого модулем. _Тем не менее, в выводе, предоставленном lsusb -t, есть важная информация. Когда существует соответствующий модуль, его имя появляется в конце строки для устройства, как в Driver=btusb._ Класс устройства определяет общую категорию, например, Устройство интерфейса пользователя, Беспроводная связь, Специфический класс поставщика, Массовое хранилище и т. д. Чтобы проверить, какое устройство использует модуль btusb, представленный в предыдущем листинге, номера `Bus` и `Dev` должны быть указаны в опции `-s` команды lsusb:

```
lsusb -s 01:3
Bus 001 Device 003: ID 0461:554a Primax Electronics, Ltd HP 125 Wired Keyboard
```

Обычно в стандартной системе Linux в любой момент времени имеется большой набор загруженных модулей (драйверов) ядра. Предпочтительным способом взаимодействия с ними является использование команд, предоставляемых пакетом `kmod`, который представляет собой набор инструментов для выполнения общих задач с модулями (драйверами) ядра Linux, таких как вставка, удаление, вывод списка, проверка свойств, разрешение зависимостей и псевдонимов. Например, команда `lsmod` показывает все загруженные в данный момент модули:
